<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Référentiel DD&RS – Arbre Radial Coloré</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; overflow: auto;
      font-family: sans-serif;
    }
    #chart {
      width: 100vw;
      height: calc(100vh - 3.5em);
      overflow: auto;
    }
    svg {
      display: block;
      width: 100%;
      height: 100%;
    }
    .node:hover circle {
      stroke: orange;
      stroke-width: 2px;
    }
  </style>
</head>
<body>
  <div id="chart"></div>
  <script>
  document.addEventListener("DOMContentLoaded", () => {
    // —————————————
    // Définition des couleurs
    const rootColor  = "#2c3e50";                   
    const axisColors = [
      "#6a619c", "#e84e4e", "#dd945b",
      "#7fb475", "#47c4e0"
    ];
    // —————————————

    // Ton objet data…
    const data = { /* … ta structure hiérarchique … */ };

    // 1) Fonction wrap pour le retour à la ligne
    function wrap(text, width) {
      text.each(function() {
        const textEl    = d3.select(this);
        const words     = textEl.text().split(/\s+/).reverse();
        let   word, line = [], lineNum = 0;
        const lineH     = 1.1;
        const y         = +textEl.attr("y") || 0;
        const x         = +textEl.attr("x") || 0;
        const dy        = parseFloat(textEl.attr("dy")) || 0;

        let tspan = textEl.text(null)
          .append("tspan")
            .attr("x", x)
            .attr("y", y)
            .attr("dy", dy + "em");

        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            lineNum++;
            tspan = textEl.append("tspan")
              .attr("x", x)
              .attr("y", y)
              .attr("dy", (lineNum * lineH + dy) + "em")
              .text(word);
          }
        }
      });
    }

    // 2) Plier tout le sous-arbre
    function collapseAll(d) {
      if (!d.children) return;
      d.children.forEach(collapseAll);
      d._children = d.children;
      d.children  = null;
    }

    // 3) Appliquer les couleurs
    function applyColors(root) {
      root.color = rootColor;
      root.children.forEach((ax, i) => ax.color = axisColors[i]);
      root.each(d => {
        if (d.depth >= 2) {
          let anc = d;
          while (anc.depth > 1) anc = anc.parent;
          const factor = 0.7 + 0.3 * (d.depth - 1);
          d.color = d3.color(anc.color).brighter(factor).formatHex();
        }
      });
    }

    // 4) Génération de l'arbre radial
    function chart() {
      const W      = window.innerWidth;
      const H      = window.innerHeight;
      const radius = Math.min(W, H) / 2 - 80;
      const tree   = d3.tree().size([2 * Math.PI, radius]);
      const root   = d3.hierarchy(data);

      // 4.1) id + sauvegarde des enfants
      let id = 0;
      root.each(d => {
        d.id        = id++;
        d._children = d.children;
      });

      // 4.2) au démarrage, plier depth ≥ 2
      root.each(d => {
        if (d.depth >= 2 && d.children) collapseAll(d);
      });

      applyColors(root);
      tree(root);

      // 4.3) création du SVG
      const svg = d3.create("svg")
        .attr("viewBox", [-W/2, -H/2, W, H])
        .style("font", "12px sans-serif")
        .style("user-select", "none");

      const g        = svg.append("g");
      const linkG    = g.append("g").attr("class","links");
      const nodeG    = g.append("g").attr("class","nodes");
      const diagonal = d3.linkRadial().angle(d=>d.x).radius(d=>d.y);

      // 4.4) fonction update
      function update() {
        tree(root);
        applyColors(root);

        // liens
        linkG.selectAll("path.link")
          .data(root.links(), d=>d.target.id)
          .join(
            enter => enter.append("path")
                          .attr("class","link")
                          .attr("d", diagonal)
                          .attr("stroke","#999")
                          .attr("fill","none"),
            upd   => upd.transition().duration(300).attr("d", diagonal),
            exit  => exit.remove()
          );

        // nœuds
        nodeG.selectAll("g.node")
          .data(root.descendants(), d=>d.id)
          .join(
            enter => {
              const ng = enter.append("g")
                .attr("class","node")
                .attr("transform", d => {
                  const ang = d.x - Math.PI/2;
                  return `translate(${d.y*Math.cos(ang)},${d.y*Math.sin(ang)})`;
                })
                .style("cursor", d =>
                  d.depth === 1 && d._children ? "pointer" : "default"
                )
                .on("click", (e,d) => {
                  if (d.depth !== 1) return;
                  // fermer tous les axes
                  root.children.forEach(collapseAll);
                  // basculer l’axe cliqué
                  if (d._children) {
                    d.children  = d._children;
                    d._children = null;
                  } else {
                    collapseAll(d);
                  }
                  update();
                });

              // cercle
              ng.append("circle")
                .attr("r", d =>
                  d.depth === 0 ? 14 :
                  d.depth === 1 ? 10 : 6
                )
                .attr("fill", d=>d.color)
                .attr("stroke","#333");

              // texte + wrapping
              ng.append("text")
                .attr("x", d =>
                  d.depth === 0 ? 0 :
                  d.x < Math.PI ? 12 : -12
                )
                .attr("dy", d =>
                  d.depth === 0 ? "-1.6em" : "0.31em"
                )
                .attr("text-anchor", d =>
                  d.depth === 0 ? "middle" :
                  d.x < Math.PI ? "start" : "end"
                )
                .style("font-weight", d =>
                  d.depth <= 1 ? "bold" : "normal"
                )
                .style("font-size", d =>
                  d.depth === 0 ? "30px" : "15px"
                )
                .style("fill", d=>d.color)
                .text(d=>d.data.name)
                .call(wrap, 80);

              return ng;
            },
            upd => upd.transition().duration(300)
                      .attr("transform", d => {
                        const ang = d.x - Math.PI/2;
                        return `translate(${d.y*Math.cos(ang)},${d.y*Math.sin(ang)})`;
                      }),
            exit => exit.remove()
          );
      }

      update();
      return svg.node();
    }

    // 5) Rendu et resize
    const container = document.getElementById("chart");
    function render() {
      container.innerHTML = "";
      container.appendChild(chart());
    }
    window.addEventListener("resize", render);
    render();
  });
  </script>
</body>
</html>
